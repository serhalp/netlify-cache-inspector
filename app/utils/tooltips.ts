/**
 * Tooltip definitions for cache analysis fields
 */

export interface TooltipDefinition {
  text: string
  url?: string
}

// RFC 9211 forward reason definitions
const FORWARD_REASONS: Record<string, TooltipDefinition> = {
  'bypass': {
    text: 'The cache was configured to not store this response or to not use a stored response for this request.',
  },
  'method': {
    text: 'The request method was such that a cache is not allowed to store a response.',
  },
  'uri-miss': {
    text: 'The cache did not have a stored response for this request URI.',
  },
  'vary-miss': {
    text: 'The cache had a stored response for this request URI, but it could not be used because the Vary header field(s) differed.',
  },
  'miss': {
    text: 'The cache did not have a stored response that could be used for this request.',
  },
  'request': {
    text: 'The request included a cache directive (e.g., no-cache) that prevented the cache from returning a stored response.',
  },
  'stale': {
    text: 'The cache had a stored response that was stale (expired).',
  },
  'partial': {
    text: 'The cache responded with a partial stored response.',
  },
}

// Cache name specific tooltips
const CACHE_NAME_TOOLTIPS: Record<string, TooltipDefinition> = {
  'Netlify Edge': {
    text: 'Netlify\'s global edge cache layer that serves cached content from locations closest to users.',
    url: 'https://docs.netlify.com/platform/caching/',
  },
  'Netlify Durable': {
    text: 'An opt-in cache layer that is shared regionally; checked when the Edge Cache falls through. Enabled by adding the "durable" directive to your Cache-Control header (e.g., "public, max-age=0, must-revalidate, durable").',
    url: 'https://docs.netlify.com/build/caching/caching-overview/#durable-directive',
  },
  'Next.js': {
    text: 'Next.js application-level caching system that caches rendered pages and API responses.',
    url: 'https://nextjs.org/docs/app/guides/caching#full-route-cache',
  },
}

// General field tooltips
export const FIELD_TOOLTIPS: Record<string, TooltipDefinition> = {
  'served-by': {
    text: 'The service or component that ultimately served this response to the user.',
  },
  'cdn-nodes': {
    text: 'The specific CDN node(s) that handled this request, identified by unique node IDs.',
  },
  'hit': {
    text: 'Whether this cache layer had a stored response that could be used for this request.',
  },
  'forwarded-because': {
    text: 'The reason why this cache layer forwarded the request instead of serving a cached response.',
  },
  'forwarded-status': {
    text: 'The HTTP status code returned when the cache forwarded the request.',
  },
  'ttl': {
    text: 'Time To Live - how long this response can be cached before it expires.',
  },
  'stored-response': {
    text: 'Whether this cache layer stored the response for future use.',
  },
  'collapsed-requests': {
    text: 'Whether multiple identical requests were collapsed into a single request to reduce server load.',
  },
  'cache-key': {
    text: 'The unique identifier used by the cache to store and retrieve this response.',
  },
  'extra-details': {
    text: 'Additional implementation-specific details about how this cache layer handled the request.',
  },
  'cacheable': {
    text: 'Whether this response is allowed to be cached based on its headers and HTTP method. Note: This field is not 100% implemented yet and may not be fully reliable.',
  },
  'age': {
    text: 'How long this response has been cached, in seconds since it was first stored.',
  },
  'date': {
    text: 'The timestamp when this response was originally generated by the server.',
  },
  'etag': {
    text: 'A unique identifier for this version of the resource, used for conditional requests and validation.',
  },
  'expires-at': {
    text: 'The specific date and time when this cached response will expire.',
  },
  'ttl-browser': {
    text: 'How long browsers are allowed to cache this response before revalidating.',
  },
  'ttl-cdn': {
    text: 'How long CDN servers are allowed to cache this response before revalidating.',
  },
  'ttl-netlify-cdn': {
    text: 'How long Netlify\'s CDN specifically is allowed to cache this response.',
  },
  'vary': {
    text: 'Headers that determine cache variations - responses will be cached separately based on these header values.',
  },
  'netlify-vary': {
    text: 'Netlify-specific header that controls cache key variation. Allows you to cache different versions of a response based on query parameters, cookies, headers, or language. Use this to create separate cache entries for different user contexts.',
    url: 'https://docs.netlify.com/build/caching/caching-overview/#cache-key-variation',
  },
  'revalidation': {
    text: 'Cache revalidation directives that control when and how cached responses should be refreshed.',
  },
}

/**
 * Get tooltip for a cache name, with special handling for known cache types
 */
export function getCacheNameTooltip(cacheName: string): TooltipDefinition {
  const tooltip = CACHE_NAME_TOOLTIPS[cacheName]
  if (tooltip) {
    return tooltip
  }

  return {
    text: `Third-party cache layer "${cacheName}" along the request path that can store and serve cached responses.`,
  }
}

/**
 * Get tooltip for a forward reason value
 */
export function getForwardReasonTooltip(reason: string): TooltipDefinition {
  const tooltip = FORWARD_REASONS[reason]
  if (tooltip) {
    return tooltip
  }

  return {
    text: `Cache forwarding reason: ${reason}`,
  }
}

/**
 * Get tooltip for a field, with fallback for unknown fields
 */
export function getFieldTooltip(fieldKey: string): TooltipDefinition {
  const tooltip = FIELD_TOOLTIPS[fieldKey]
  if (tooltip) {
    return tooltip
  }

  return {
    text: `Information about ${fieldKey}`,
  }
}

/**
 * Create a tooltip string with optional URL for links
 */
export function formatTooltip(definition: TooltipDefinition): string {
  if (definition.url) {
    return `${definition.text}\n\nLearn more: ${definition.url}`
  }
  return definition.text
}
